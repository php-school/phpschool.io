<p>In this section we will learn how to create a simple check. If you don't fully understand what checks are, head over
    to the <a href="/docs/reference/exercise-types">Exercise Checks section</a>.</p>

<p>We will build a fairly boring check which verifies that a students solution passes the PSR2 coding standard.
    Lets get started!</p>

<p>Creating an check begins with creating a file and class for our check . We need to implement the interface
    <code>\PhpSchool\PhpWorkshop\Check\SimpleCheckInterface</code> which extends from
    <code>\PhpSchool\PhpWorkshop\Check\CheckInterface</code>. Lets breakdown these methods before we start coding:</p>

<h3><code>getName()</code></h3>
<p>This method should just return a <code>string</code> which represents the name of the check. This will be printed on
    the terminal during the verification process. This will be <code>PSR2 Code Check</code> for our check.</p>

<h3><code>getExerciseInterface()</code></h3>
<p>This method should just return a <code>string</code> which is the FQCN of the interface that the exercise needs
    to implement when requiring our check. Because we don't need any extra information for our check we can just use
    <code>PhpSchool\PhpWorkshop\Exercise\ExerciseInterface</code>.</p>

<h3><code>canRun(ExerciseType $exerciseType)</code></h3>
<p>This method receives an <code>ExerciseType</code> instance which represents the type of exercise, we used this to
    inform the workshop which exercise types our check works with: CLI or CGI. We will support both, so we will just
    return true in here.</p>

<h3><code>check(ExerciseInterface $exercise, $fileName)</code></h3>
<p>This is the method where we actually perform our check logic, executing PHPCS. This method receives an instance of
    the current exercise and the file name of the students submission.</p>

<p>We also need to return an instance of <code>PhpSchool\PhpWorkshop\Result\ResultInterface</code>. Depending on
    whether you want a success or failure to be recorded it will be an instance of
    <code>PhpSchool\PhpWorkshop\Result\SuccessInterface</code> or
    <code>\PhpSchool\PhpWorkshop\Result\FailureInterface</code>.</p>

<h3><code>getPosition()</code></h3>
<p>This method should return one of two constants
    <code>PhpSchool\PhpWorkshop\Check\SimpleCheckInterface::CHECK_BEFORE</code>,
    <code>PhpSchool\PhpWorkshop\Check\SimpleCheckInterface::CHECK_AFTER</code>. This value denotes when the check is
    run.</p>

<p>The process of verifying a students submission looks something like the following (pseudo code):</p>

<pre><code class="lang-php">//run before checks
foreach ($beforeChecks as $check) {
    $result = $check->check($exercise, $submissionFilePath);

    if (!$result->isSuccessful) {
        return;
    }
}

//compare output of student solution and known working solution
$this->verifier->compareOutput($exercise);

foreach ($afterChecks as $check) {
    $result = $check->check($exercise, $submissionFilePath);
    //store result
}
</code></pre>

<h4>Before Verifying</h4>
<p>When a check is required in <code>CHECK_BEFORE</code> mode it is run before the output verification. The process is
    also short circuited if a check returns a failure. No more checks will be run and the output will
    not be compared.</p>

<h4>After Verifying</h4>
<p>When a check is required in <code>CHECK_AFTER</code> mode it is run after the output verification. This means that
    the check is run after the students submission has been run. After checks are useful for verifying that something
    was actually performed in the students submission, for example, inserting a row into the database.</p>

<?= $this->renderDocHeader('build-check', 'Build the check') ?>

<p>Now - let's build it! We will use the already built example workshop as a base - the already working code is
    available on the <code>custom-simple-check</code> branch of the
    <a href="https://github.com/php-school/simple-math">tutorial repository</a>. We will start fresh from the
    <code>master</code> branch for this tutorial, so if you haven't already got it, git
    clone it and install the dependencies:</p>

<div class="terminal">
    <div class="terminal-head">
        <span class="terminal__button"></span>
        <span class="terminal__button"></span>
        <span class="terminal__button"></span>
    </div>
    <div class="terminal__body">
        <p>cd projects</p>
        <p>git clone git@github.com:php-school/simple-math.git</p>
        <p>cd simple-math</p>
        <p>composer install</p>
    </div>
</div>

<p>Our check will run the <a href="https://github.com/squizlabs/PHP_CodeSniffer">PHP_CodeSniffer</a> tool against the
student's submission and report a success or failure based on the result.</p>

<h3>1. Require the PHP_CodeSniffer tool as a dependency</h3>

<div class="terminal">
    <div class="terminal-head">
        <span class="terminal__button"></span>
        <span class="terminal__button"></span>
        <span class="terminal__button"></span>
    </div>
    <div class="terminal__body">
        <p>composer require squizlabs/php_codesniffer</p>
    </div>
</div>

<h3>2. Create the folder and class</h3>

<p>First we need to create the folder and file for our class:</p>

<div class="terminal">
    <div class="terminal-head">
        <span class="terminal__button"></span>
        <span class="terminal__button"></span>
        <span class="terminal__button"></span>
    </div>
    <div class="terminal__body">
        <p>mkdir src/Check</p>
        <p>touch src/Check/Psr2Check.php</p>
    </div>
</div>

<h3>3. Write the class</h3>

<pre><code class="lang-php">&lt?php

namespace PhpSchool\SimpleMath\Check;

use PhpSchool\PhpWorkshop\Check\SimpleCheckInterface;
use PhpSchool\PhpWorkshop\Exercise\ExerciseInterface;
use PhpSchool\PhpWorkshop\Exercise\ExerciseType;
use PhpSchool\PhpWorkshop\Result\Failure;
use PhpSchool\PhpWorkshop\Result\Success;

class Psr2Check implements SimpleCheckInterface
{

    public function getName()
    {
        return 'PSR2 Code Check';
    }

    public function getExerciseInterface()
    {
        return ExerciseInterface::class;
    }

    public function canRun(ExerciseType $exerciseType)
    {
        return true;
    }

    public function check(ExerciseInterface $exercise, $fileName)
    {
        $phpCsBinary = __DIR__ . '/../../vendor/bin/phpcs';
        $cmd = sprintf('%s %s --standard=PSR2', $phpCsBinary, $fileName);
        exec($cmd, $output, $exitCode);

        if ($exitCode === 0) {
            return new Success($this->getName());
        }

        return new Failure($this->getName(), 'Coding style did not conform to PSR2!');
    }

    public function getPosition()
    {
        return static::CHECK_BEFORE;
    }
}
</code></pre>

<p>If the <code>phpcs</code> binary returns a non-zero exit code - a failure occurred e.g. the submission did not pass
    the coding standard check. So we return a failure with an error message. Otherwise a Success is returned.</p>

<p class="note note-info">As we brought in the tool via Composer, we can rest assured that the binary <code>phpcs</code>
    is available in our projects <code>vendor</code> directory.</p>

<h3>4. Register the Check and add a factory</h3>
<p>Now you need to tell the application about your new check. We need to register a factory.
    <a href="/docs/reference/container">What's a factory?</a> Open up <code>app/config.php</code> and add an entry for
    your, resulting file should look like:</p>

<pre><code class="lang-php">&lt?php

use function DI\factory;
use function DI\object;
use Interop\Container\ContainerInterface;
use PhpSchool\SimpleMath\Check\Psr2Check;
use PhpSchool\SimpleMath\Exercise\Mean;
use Symfony\Component\Filesystem\Filesystem;

return [
    //Define your exercise factories here
    Mean::class => factory(function (ContainerInterface $c) {
        return new Mean($c->get(Filesystem::class));
    }),

    //my checks
    Psr2Check::class => object(),
];
</code></pre>

<p>Note the new entry for <code>Psr2Check::class => object(),</code>. Finally we need to tell the application about our
check in <code>app/bootstrap.php</code>. After the application object is created you just call <code>addCheck</code>
with the name of check class. Your final <code>app/bootstrap.php</code> file should look something like:</p>

<pre><code class="lang-php">&lt?php

ini_set('display_errors', 1);
date_default_timezone_set('Europe/London');
switch (true) {
    case (file_exists(__DIR__ . '/../vendor/autoload.php')):
        // Installed standalone
        require __DIR__ . '/../vendor/autoload.php';
        break;
    case (file_exists(__DIR__ . '/../../../autoload.php')):
        // Installed as a Composer dependency
        require __DIR__ . '/../../../autoload.php';
        break;
    case (file_exists('vendor/autoload.php')):
        // As a Composer dependency, relative to CWD
        require 'vendor/autoload.php';
        break;
    default:
        throw new RuntimeException('Unable to locate Composer autoloader; please run "composer install".');
}

use PhpSchool\PhpWorkshop\Application;
use PhpSchool\SimpleMath\Check\Psr2Check;
use PhpSchool\SimpleMath\Exercise\Mean;

$app = new Application('Simple Math', __DIR__ . '/config.php');

$app->addExercise(Mean::class);
$app->addCheck(Psr2Check::class);

$art = <<<ART
  ∞ ÷ ∑ ×

 PHP SCHOOL
SIMPLE MATH
ART;

$app->setLogo($art);
$app->setFgColour('red');
$app->setBgColour('black');

return $app;
</code></pre>

<h3>5. Require the check in an exercise</h3>
<p>Open up the Mean Average exercise file: <code>src/Exercise/Mean.php</code> and add in the following method, take care to import the
    necessary classes (<code>PhpSchool\PhpWorkshop\ExerciseDispatcher</code> &
    <code>PhpSchool\SimpleMath\Check\Psr2Check</code>):</p>

<pre><code class="lang-php">public function configure(ExerciseDispatcher $dispatcher)
{
    $dispatcher->requireCheck(Psr2Check::class);
}
</code></pre>
<p>Hopefully you will remember this from the previous section - we are just telling the exercise to use our custom
    check!</p>

<?= $this->renderDocHeader('try-it-out', 'Try it out!') ?>

<p>Run the workshop and select the Mean Average exercise. Verifying a solution which does not pass PSR2 will yield
    the output:</p>
<img src="/img/custom-simple-check-psr2-fail.png" class="doc-terminal-screen">
<p>And a solution which <strong>does</strong> pass will yield the output:</p>
<img src="/img/custom-simple-check-psr2-success.png" class="doc-terminal-screen">
<hr>

<?= $this->renderDocHeader('custom-interface', 'Custom Interface') ?>
<p>When you build checks, sometimes you need extra information from the exercise to configure the check. For
    example, the <a href="https://github.com/php-school/php-workshop/blob/master/src/Check/FunctionRequirementsCheck.php">FunctionRequirementsCheck</a> check
    calls <code>getRequiredFunctions</code> & <code>getBannedFunctions</code> on the exercise, these methods are defined
    on the extra interface <code>FunctionRequirementsExerciseCheck</code> which the exercise must implement if it requires the
    <code>FunctionRequirementsCheck</code> check.</p>

<p>Maybe we want to make the standard for our Check configurable - it could be PSR1, PSR2, PEAR or any of the other
    standards PHPCS supports. We will make this configuration available through the method <code>getStandard</code>.</p>

<h3>1. Define our interface</h3>
<p>We need an interface to define our required method. Lets do that.</p>

<div class="terminal">
    <div class="terminal-head">
        <span class="terminal__button"></span>
        <span class="terminal__button"></span>
        <span class="terminal__button"></span>
    </div>
    <div class="terminal__body">
        <p>mkdir src/ExerciseCheck</p>
        <p>touch src/ExerciseCheck/Psr2ExerciseCheck.php</p>
    </div>
</div>

<p>Now would probably be a good idea to change our check name to something a little less specific, but we'll leave that
up to you, probably <code>PhpCsCheck</code> might be a little better. Okay, lets define our interface. We want the one
method <code>getStandard</code> to return a string representing one of the
    <a href="https://github.com/squizlabs/PHP_CodeSniffer/tree/master/CodeSniffer/Standards">available standards</a>:
</p>


<pre><code class="lang-php">&lt;?php

namespace PhpSchool\SimpleMath\ExerciseCheck;

interface Psr2ExerciseCheck
{
    /**
     * @return string
     */
    public function getStandard();
}
</code></pre>

<h3>2. Update our check</h3>
<p>We need to update the <code>getExerciseInterface</code> method in our check to return the name of our new interface.
Open up <code>src/Check/Psr2Check.php</code> and change the <code>getExerciseInterface</code> method to match below:</p>

<pre><code class="lang-php">public function getExerciseInterface()
{
    return Psr2ExerciseCheck::class;
}
</code></pre>

<p>We also need to modify our <code>check</code> method to actually use this data:</p>

<pre><code class="lang-php">public function check(ExerciseInterface $exercise, $fileName)
{
    if (!$exercise instanceof Psr2ExerciseCheck) {
        throw new \InvalidArgumentException;
    }

    $standard = $exercise->getStandard();

    if (!in_array($standard, ['PSR1', 'PSR2', 'PEAR'])) {
        throw new \InvalidArgumentException('Standard is not supported');
    }

    $phpCsBinary = __DIR__ . '/../../vendor/bin/phpcs';
    $cmd = sprintf('%s %s --standard=%s', $phpCsBinary, $fileName, $standard);
    exec($cmd, $output, $exitCode);

    if ($exitCode === 0) {
        return new Success($this->getName());
    }

    return new Failure($this->getName(), 'Coding style did not conform to PSR2!');
}
</code></pre>
<p>We've added a couple of things here - we make sure the exercise actually implements our required exception, if not
we throw an exception. We check if the standard provided is in a small subset of supported standards, and finally,
we pass the standard along to the <code>phpcs</code> command.</p>

<h3>3. Update our exercise</h3>
<p>Now we have to implement the new interface and methods in our exercise, for our Mean Average exercise, we will
still require PSR2 as the coding standard. The final exercise should look similar to below:</p>

<pre><code class="lang-php">&lt;?php

namespace PhpSchool\SimpleMath\Exercise;

use PhpSchool\PhpWorkshop\Exercise\AbstractExercise;
use PhpSchool\PhpWorkshop\Exercise\CliExercise;
use PhpSchool\PhpWorkshop\Exercise\ExerciseInterface;
use PhpSchool\PhpWorkshop\Exercise\ExerciseType;
use PhpSchool\PhpWorkshop\ExerciseDispatcher;
use PhpSchool\SimpleMath\Check\Psr2Check;
use PhpSchool\SimpleMath\ExerciseCheck\Psr2ExerciseCheck;

class Mean extends AbstractExercise implements ExerciseInterface, CliExercise, Psr2ExerciseCheck
{

    /**
     * @return string
     */
    public function getName()
    {
        return 'Mean Average';
    }

    /**
     * @return string
     */
    public function getDescription()
    {
        return 'Simple Math';
    }

    /**
     * @return array
     */
    public function getArgs()
    {
        $numArgs = rand(0, 10);

        $args = [];
        for ($i = 0; $i < $numArgs; $i ++) {
            $args[] = rand(0, 100);
        }

        return $args;
    }

    /**
     * @return ExerciseType
     */
    public function getType()
    {
        return ExerciseType::CLI();
    }

    public function configure(ExerciseDispatcher $dispatcher)
    {
        $dispatcher->requireCheck(Psr2Check::class);
    }

    /**
     * @return string
     */
    public function getStandard()
    {
        return 'PSR2';
    }
}</code></pre>

<p>You should be able to run it just as above, you can now easily update your exercise to use a different coding
standard without modifying the check.</p>

<p class="note note-success">Maybe you could try updating the check to take into account the standard when return the
    result? It currently has PSR2 hardcoded!</p>

<p>You can see the finished, working result on the <code>custom-interface-check</code> branch of the
    <a href="https://github.com/php-school/simple-math">tutorial repository</a>.</p>
