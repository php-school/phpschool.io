<p>Internally, the workshop framework uses a <a target="_blank" href="https://en.wikipedia.org/wiki/Dependency_Injection">dependency injection container</a>. This allows you to request other services from the application and replace services with your own implementations. We use the <a target="_blank" href="http://php-di.org">PHP-DI</a> package for dependency injection, a <doc-code>container-interop</doc-code> compatible dependency injection container.</p>
<p>Services are configured in <doc-code>app/config.php</doc-code>. You can use all of the features of <a target="_blank" href="http://php-di.org">PHP-DI</a> so check the docs there.</p>

<p>The file <doc-code>app/config.php</doc-code> should return an array of service definitions for the container. The key being the name of the service and the value the actual factory.</p>

<content-header id="defining-factories">Defining Factories</content-header>

<h3 id="no-deps">Simple Object with No dependencies</h3>
<p><doc-code>\DI\Object()</doc-code> is a helper function to create a factory which will simply run <doc-code>new $yourClassName</doc-code> when asking for the service from the container.</p>
<pre><code lang="php">return [
    ...snip
    Generator::class => \DI\Object(),
];
</code></pre>
<h3 id="with-deps">Object with dependencies</h3>

<p>PHP-DI provides more powerful features such as being able to use anonymous functions and any valid PHP <doc-code>callables</doc-code> as a factory. When using a callable your callable will be injected with the container itself which you can pull other services from!</p>
<p>If you pulled in a third party library for random number generation you might define a service like below. We use the battle tested package: <doc-code>ircmaxell/random-lib</doc-code> as an example.</p>
<p>We use an anonymous function and pull the strength parameter from the container and create a new random number generator based on that.</p>
<pre><code lang="php">return [
    ...snip
    \RandomLib\Generator::class => \DI\factory(function (ContainerInterface $container) {
        $strength = $container->get('random-number-generator-strength');
        $factory = new \RandomLib\Factory;
        return $factory->getGenerator(new \SecurityLib\Strength($strength));
    }),
];
</code></pre>

<content-header id="overwriting-services">Overwriting existing services</content-header>

<p>As your workshop configuration is merged into default workshop framework configuration, you can override existing services with your own implementation. Maybe you want to override the <doc-code>\Symfony\Component\Filesystem\Filesystem</doc-code> service with your own version, maybe you extended it to add some methods.</p>
<p>The below definition would replace the <doc-code>Symfony\Component\Filesystem\Filesystem</doc-code> service with your own implementation: <doc-code>MyFileSystem</doc-code> which extends from <doc-code>\Symfony\Component\Filesystem\Filesystem</doc-code>.</p>

<pre><code lang="php">return [
    ...snip
    Symfony\Component\Filesystem\Filesystem::class => \DI\factory(function (ContainerInterface $c) {
        return new MyFileSystem;
    }),
];
</code></pre>

<p>Now when you ask the container for <doc-code>Symfony\Component\Filesystem\Filesystem</doc-code> you will receive an instance of <doc-code>MyFileSystem</doc-code>.</p>
<note type="warning">Be aware that anything already using the <doc-code>Symfony\Component\Filesystem\Filesystem</doc-code> service will expect it to be an instance of <doc-code>\Symfony\Component\Filesystem\Filesystem</doc-code>, so if you replace it with an altogether different object, expect things to break!</note>

<p>Check <a href="/docs/reference/available-services">Available Services</a> for a list and description of services available to you.</p>
